#!/usr/bin/env node

/**
 * Script to update component imports to use barrel exports
 * 
 * Usage:
 *   node scripts/update-component-imports.js [--dry-run]
 * 
 * This script reads the data generated by find-component-imports.js
 * and updates import statements throughout the codebase to use barrel exports.
 * 
 * Options:
 *   --dry-run    Show changes without modifying files
 *   --pattern    Only update specific pattern (ui, domain, etc.)
 */

const fs = require('fs');
const path = require('path');

// Parse command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');
const patternArg = args.find(arg => arg.startsWith('--pattern='));
const specificPattern = patternArg ? patternArg.split('=')[1] : null;

// Read the data file
function readUpdateData() {
  try {
    const dataPath = path.join(process.cwd(), 'scripts', 'update-imports.json');
    if (fs.existsSync(dataPath)) {
      return JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    } else {
      console.error('Error: update-imports.json not found');
      console.error('Run scripts/find-component-imports.js > scripts/update-imports.json first');
      process.exit(1);
    }
  } catch (error) {
    console.error('Error reading update data:', error);
    process.exit(1);
  }
}

// Update imports in a file
function updateImportsInFile(file, patterns) {
  console.log(`Processing ${file}${isDryRun ? ' (dry run)' : ''}`);
  
  try {
    let content = fs.readFileSync(file, 'utf8');
    let originalContent = content;
    let changes = 0;
    
    // Apply each pattern
    patterns.forEach(pattern => {
      const regex = new RegExp(pattern.regex, 'g');
      const matches = [...content.matchAll(regex)];
      
      if (matches.length > 0) {
        matches.forEach(match => {
          let replacement;
          
          if (pattern.isDomain) {
            // For domain-specific imports, we need to extract the domain name
            const domain = match[1];
            replacement = pattern.replacement.replace('$1', domain);
          } else {
            replacement = pattern.replacement;
          }
          
          // Get the component name
          const componentName = match[pattern.isDomain ? 2 : 1];
          const originalImport = match[0];
          const newImport = originalImport.replace(/from\s+["']@\/components\/.*["']/, replacement);
          
          console.log(`  ${originalImport} => ${newImport}`);
          // Replace the import statement
          content = content.replace(originalImport, newImport);
          changes++;
        });
      }
    });
    
    // Only write if changes were made and not in dry run mode
    if (changes > 0 && !isDryRun && content !== originalContent) {
      fs.writeFileSync(file, content, 'utf8');
      console.log(`  Updated ${changes} imports in ${file}`);
    } else if (changes > 0) {
      console.log(`  Would update ${changes} imports in ${file}`);
    } else {
      console.log(`  No changes needed in ${file}`);
    }
    
    return changes;
  } catch (error) {
    console.error(`Error processing ${file}:`, error);
    return 0;
  }
}

// Verify barrel exports
function verifyBarrelExports() {
  console.log('\nVerifying barrel exports...');
  
  const directories = [
    { path: 'components/ui', expectFile: 'index.ts' },
    { path: 'components/ui/core', expectFile: 'index.ts' },
    { path: 'components/ui/composite', expectFile: 'index.ts' }
  ];
  
  // Find all domain directories
  const componentsDir = path.join(process.cwd(), 'components');
  const items = fs.readdirSync(componentsDir);
  
  items.forEach(item => {
    const fullPath = path.join(componentsDir, item);
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory() && item !== 'ui' && item !== 'providers' && !item.startsWith('.')) {
      directories.push({ path: `components/${item}`, expectFile: 'index.ts' });
      
      // Check for UI subdirectory
      const uiPath = path.join(fullPath, 'ui');
      if (fs.existsSync(uiPath) && fs.statSync(uiPath).isDirectory()) {
        directories.push({ path: `components/${item}/ui`, expectFile: 'index.ts' });
      }
    }
  });
  
  // Verify each directory has the expected barrel file
  directories.forEach(dir => {
    const fullPath = path.join(process.cwd(), dir.path, dir.expectFile);
    if (fs.existsSync(fullPath)) {
      console.log(`✅ ${dir.path}/${dir.expectFile} exists`);
    } else {
      console.log(`❌ ${dir.path}/${dir.expectFile} missing`);
    }
  });
}

// Fix imports that reference directly within the ui/core directory
function fixUiCoreInternalImports() {
  console.log('\nChecking for internal imports within UI components...');
  
  const uiCorePath = path.join(process.cwd(), 'components', 'ui', 'core');
  if (!fs.existsSync(uiCorePath)) {
    console.log('UI core directory not found, skipping internal import check');
    return;
  }
  
  const files = fs.readdirSync(uiCorePath);
  let changes = 0;
  
  files.forEach(file => {
    if (/\.(tsx?|jsx?)$/.test(file) && file !== 'index.ts') {
      const filePath = path.join(uiCorePath, file);
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Look for internal imports within the same directory
      const internalImportRegex = /from\s+["']@\/components\/ui\/([^\/"]*)["']/g;
      const matches = [...content.matchAll(internalImportRegex)];
      
      if (matches.length > 0) {
        console.log(`Found internal imports in ${filePath}`);
        
        let updatedContent = content;
        matches.forEach(match => {
          const originalImport = match[0];
          const componentName = match[1];
          const newImport = originalImport.replace(/from\s+["']@\/components\/ui\/.*["']/, `from "@/components/ui"`);
          
          console.log(`  ${originalImport} => ${newImport}`);
          // Replace the import statement
          updatedContent = updatedContent.replace(originalImport, newImport);
          changes++;
        });
        
        if (!isDryRun && updatedContent !== content) {
          fs.writeFileSync(filePath, updatedContent, 'utf8');
          console.log(`  Updated ${filePath}`);
        } else if (updatedContent !== content) {
          console.log(`  Would update ${filePath} (dry run)`);
        }
      }
    }
  });
  
  console.log(`${changes} internal imports ${isDryRun ? 'would be' : 'were'} updated`);
}

// Fix barrel exports that still reference old paths
function fixBarrelExports() {
  console.log('\nChecking barrel export files...');
  
  // First check ui/core/index.ts
  const uiCoreIndexPath = path.join(process.cwd(), 'components', 'ui', 'core', 'index.ts');
  if (fs.existsSync(uiCoreIndexPath)) {
    const content = fs.readFileSync(uiCoreIndexPath, 'utf8');
    
    // Look for exports referencing the old paths
    const oldPathRegex = /export \* from "@\/components\/ui\/([^\/"]*)";/g;
    const matches = [...content.matchAll(oldPathRegex)];
    
    if (matches.length > 0) {
      console.log(`Found old path exports in components/ui/core/index.ts`);
      
      // Create updated content with relative imports
      let updatedContent = content.replace(oldPathRegex, (match, componentName) => {
        return `export * from "./${componentName}";`;
      });
      
      if (!isDryRun && updatedContent !== content) {
        fs.writeFileSync(uiCoreIndexPath, updatedContent, 'utf8');
        console.log(`  Updated ${uiCoreIndexPath}`);
      } else if (updatedContent !== content) {
        console.log(`  Would update ${uiCoreIndexPath} (dry run)`);
        console.log(`  From:\n${content}\n  To:\n${updatedContent}`);
      }
    } else {
      console.log(`✅ components/ui/core/index.ts uses correct relative paths`);
    }
  }
  
  // Check domain barrel exports
  const componentsDir = path.join(process.cwd(), 'components');
  const items = fs.readdirSync(componentsDir);
  
  items.forEach(item => {
    const fullPath = path.join(componentsDir, item);
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory() && item !== 'ui' && item !== 'providers' && !item.startsWith('.')) {
      // Check domain/ui/index.ts
      const uiIndexPath = path.join(fullPath, 'ui', 'index.ts');
      if (fs.existsSync(uiIndexPath)) {
        const content = fs.readFileSync(uiIndexPath, 'utf8');
        
        // Look for exports referencing the old paths
        const oldPathRegex = new RegExp(`export \\* from "@\\/components\\/${item}\\/ui\\/([^\\/"]*)";`, 'g');
        const matches = [...content.matchAll(oldPathRegex)];
        
        if (matches.length > 0) {
          console.log(`Found old path exports in components/${item}/ui/index.ts`);
          
          // Create updated content with relative imports
          let updatedContent = content.replace(oldPathRegex, (match, componentName) => {
            return `export * from "./${componentName}";`;
          });
          
          if (!isDryRun && updatedContent !== content) {
            fs.writeFileSync(uiIndexPath, updatedContent, 'utf8');
            console.log(`  Updated ${uiIndexPath}`);
          } else if (updatedContent !== content) {
            console.log(`  Would update ${uiIndexPath} (dry run)`);
          }
        } else {
          console.log(`✅ components/${item}/ui/index.ts uses correct relative paths`);
        }
      }
    }
  });
}

// Main function
function main() {
  console.log(`Running import update script${isDryRun ? ' (dry run)' : ''}`);
  
  const updateData = readUpdateData();
  let totalChanges = 0;
  
  // Filter patterns if specified
  let patterns = updateData.patterns;
  if (specificPattern) {
    patterns = patterns.filter(pattern => pattern.regex.includes(specificPattern));
    console.log(`Applying only patterns matching: ${specificPattern}`);
  }
  
  // Verify barrel exports exist
  verifyBarrelExports();
  
  // Fix barrel exports that still reference old paths
  fixBarrelExports();
  
  // Fix internal imports within UI components
  fixUiCoreInternalImports();
  
  // Process each file
  console.log('\nUpdating imports in files...');
  updateData.files.forEach(file => {
    const changes = updateImportsInFile(file, patterns);
    totalChanges += changes;
  });
  
  // Summary
  console.log(`\nTotal: ${totalChanges} imports ${isDryRun ? 'would be' : 'were'} updated`);
  
  if (isDryRun && totalChanges > 0) {
    console.log('\nRun without --dry-run to apply these changes');
  }
}

main();
