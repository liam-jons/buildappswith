#!/usr/bin/env node

/**
 * Fix Prisma Types Script
 * 
 * This script:
 * 1. Updates the Prisma schema to properly define JSON fields
 * 2. Regenerates the Prisma client
 * 3. Creates a proper set of type definitions for JSON fields
 * 4. Updates affected files to use the correct type handling
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const readline = require('readline');

// Define colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m'
};

console.log(`${colors.bright}${colors.cyan}=== Buildappswith Prisma Type Fix Tool ===${colors.reset}\n`);

// Paths
const ROOT_DIR = path.resolve(__dirname, '..');
const PRISMA_SCHEMA_PATH = path.join(ROOT_DIR, 'prisma', 'schema.prisma');
const PRISMA_TYPES_PATH = path.join(ROOT_DIR, 'lib', 'prisma-types.ts');

// Step 1: Update Prisma schema
async function updatePrismaSchema() {
  console.log(`${colors.yellow}Step 1: Updating Prisma schema...${colors.reset}`);
  
  try {
    // Read current schema
    let schemaContent = fs.readFileSync(PRISMA_SCHEMA_PATH, 'utf8');
    
    // Look for BuilderProfile model
    const builderProfileModelRegex = /model\s+BuilderProfile\s+{[\s\S]*?}/;
    const builderProfileModel = schemaContent.match(builderProfileModelRegex)[0];
    
    // Check if socialLinks already exists
    if (!builderProfileModel.includes('socialLinks')) {
      // Add socialLinks field
      const updatedModel = builderProfileModel.replace(
        /(\s+updatedAt\s+DateTime\s+@updatedAt)/,
        '$1\n  socialLinks       Json?     // Social media links and contact information'
      );
      
      // Replace old model with updated one
      schemaContent = schemaContent.replace(builderProfileModelRegex, updatedModel);
      
      // Write updated schema
      fs.writeFileSync(PRISMA_SCHEMA_PATH, schemaContent, 'utf8');
      console.log(`${colors.green}✓ Added socialLinks field to BuilderProfile model${colors.reset}`);
    } else {
      console.log(`${colors.green}✓ socialLinks field already exists in BuilderProfile model${colors.reset}`);
    }
    
    return true;
  } catch (error) {
    console.error(`${colors.red}Error updating Prisma schema: ${error.message}${colors.reset}`);
    return false;
  }
}

// Step 2: Generate Prisma client
async function generatePrismaClient() {
  console.log(`\n${colors.yellow}Step 2: Generating Prisma client...${colors.reset}`);
  
  try {
    execSync('npx prisma generate', { stdio: 'inherit', cwd: ROOT_DIR });
    console.log(`${colors.green}✓ Generated Prisma client successfully${colors.reset}`);
    return true;
  } catch (error) {
    console.error(`${colors.red}Error generating Prisma client: ${error.message}${colors.reset}`);
    return false;
  }
}

// Step 3: Create proper type definitions
async function createPrismaTypes() {
  console.log(`\n${colors.yellow}Step 3: Creating proper type definitions...${colors.reset}`);
  
  try {
    // Define the content for the prisma-types.ts file
    const typesContent = `/**
 * Type definitions for Prisma JSON fields
 * Auto-generated by fix-prisma-types.js
 */

import { Prisma } from "@prisma/client";

/**
 * SocialLinks type for BuilderProfile
 */
export interface SocialLinks {
  website?: string;
  linkedin?: string;
  github?: string;
  twitter?: string;
  [key: string]: any; // Allow additional properties
}

/**
 * PortfolioItemOutcome type for BuilderProfile
 */
export interface PortfolioItemOutcome {
  label: string;
  value: string;
  trend: 'up' | 'down' | 'neutral';
  type?: string;
  verified?: boolean;
}

/**
 * PortfolioItem type for BuilderProfile
 */
export interface PortfolioItem {
  id: string;
  title: string;
  description: string;
  imageUrl?: string;
  outcomes?: PortfolioItemOutcome[];
  tags?: string[];
  projectUrl?: string;
  createdAt: Date | string;
  client?: string;
  date?: string | Date;
  images?: string[];
  technologies?: string[];
  [key: string]: any; // Allow additional properties
}

// Type utilities for working with Prisma JSON fields
declare global {
  namespace PrismaJson {
    // These types help Prisma understand our JSON structures
    type BuilderProfileSocialLinks = SocialLinks;
    type BuilderProfilePortfolioItem = PortfolioItem;
  }
}

/**
 * Convert SocialLinks to a Prisma-compatible JSON value
 */
export function socialLinksToJson(links?: SocialLinks): Prisma.InputJsonValue | undefined {
  if (!links) return undefined;
  return links as unknown as Prisma.InputJsonValue;
}

/**
 * Convert PortfolioItem[] to a Prisma-compatible JSON array
 */
export function portfolioItemsToJson(items?: PortfolioItem[]): Prisma.InputJsonValue[] | undefined {
  if (!items) return undefined;
  return items as unknown as Prisma.InputJsonValue[];
}

/**
 * Get SocialLinks from a BuilderProfile
 */
export function getSocialLinks(profile: { socialLinks?: Prisma.JsonValue | null }): SocialLinks | undefined {
  if (!profile.socialLinks) return undefined;
  return profile.socialLinks as unknown as SocialLinks;
}

/**
 * Get PortfolioItems from a BuilderProfile
 */
export function getPortfolioItems(profile: { portfolioItems?: Prisma.JsonValue[] }): PortfolioItem[] | undefined {
  if (!profile.portfolioItems || !Array.isArray(profile.portfolioItems)) return undefined;
  return profile.portfolioItems as unknown as PortfolioItem[];
}

// Export the utility functions
export const PrismaJsonUtils = {
  socialLinksToJson,
  portfolioItemsToJson,
  getSocialLinks,
  getPortfolioItems
};

export default PrismaJsonUtils;
`;

    // Write the file
    fs.writeFileSync(PRISMA_TYPES_PATH, typesContent, 'utf8');
    console.log(`${colors.green}✓ Created Prisma type definitions at ${PRISMA_TYPES_PATH}${colors.reset}`);
    return true;
  } catch (error) {
    console.error(`${colors.red}Error creating type definitions: ${error.message}${colors.reset}`);
    return false;
  }
}

// Step 4: Update Builder type definition
async function updateBuilderType() {
  console.log(`\n${colors.yellow}Step 4: Updating Builder type definition...${colors.reset}`);
  
  try {
    const builderTypePath = path.join(ROOT_DIR, 'lib', 'types', 'builder.ts');
    let builderTypeContent = fs.readFileSync(builderTypePath, 'utf8');
    
    // Update the imports
    if (!builderTypeContent.includes('import { SocialLinks, PortfolioItem as PrismaPortfolioItem }')) {
      builderTypeContent = builderTypeContent.replace(
        /import \{ Prisma \} from "@prisma\/client";/,
        'import { Prisma } from "@prisma/client";\nimport { SocialLinks, PortfolioItem as PrismaPortfolioItem, socialLinksToJson, portfolioItemsToJson } from \'@/lib/prisma-types\';'
      );
    }
    
    // Update the portfolioItemsToPrisma function
    builderTypeContent = builderTypeContent.replace(
      /export function portfolioItemsToPrisma[\s\S]*?}/,
      'export function portfolioItemsToPrisma(items: PortfolioItem[] | undefined): Prisma.InputJsonValue[] | undefined {\n  return portfolioItemsToJson(items);\n}'
    );
    
    // Update the socialLinksToPrisma function
    builderTypeContent = builderTypeContent.replace(
      /export function socialLinksToPrisma[\s\S]*?}/,
      'export function socialLinksToPrisma(links: SocialLinks | undefined): Prisma.InputJsonValue | undefined {\n  return socialLinksToJson(links);\n}'
    );
    
    // Write the updated file
    fs.writeFileSync(builderTypePath, builderTypeContent, 'utf8');
    console.log(`${colors.green}✓ Updated Builder type definition${colors.reset}`);
    return true;
  } catch (error) {
    console.error(`${colors.red}Error updating Builder type: ${error.message}${colors.reset}`);
    return false;
  }
}

// Step 5: Update builder service files
async function updateBuilderServices() {
  console.log(`\n${colors.yellow}Step 5: Updating builder service files...${colors.reset}`);
  
  try {
    // Update builder-service.ts to use proper JSON handling
    const builderServicePath = path.join(ROOT_DIR, 'lib', 'services', 'builder-service.ts');
    let builderServiceContent = fs.readFileSync(builderServicePath, 'utf8');
    
    // Update the imports
    if (!builderServiceContent.includes('import { getSocialLinks }')) {
      builderServiceContent = builderServiceContent.replace(
        /import \{ portfolioItemsToPrisma, socialLinksToPrisma \} from '@\/lib\/types\/builder';/,
        'import { portfolioItemsToPrisma, socialLinksToPrisma } from \'@/lib/types/builder\';\nimport { getSocialLinks } from \'@/lib/prisma-types\';'
      );
    }
    
    // Update the getSocialLinks calls
    builderServiceContent = builderServiceContent.replace(
      /PrismaExtensions\.getSocialLinks\(builder\) \|\| \{\}/g,
      'getSocialLinks(builder) || {}'
    );
    
    // Write the updated file
    fs.writeFileSync(builderServicePath, builderServiceContent, 'utf8');
    console.log(`${colors.green}✓ Updated builder-service.ts${colors.reset}`);
    
    // Update builder-profile-service.ts
    const profileServicePath = path.join(ROOT_DIR, 'lib', 'services', 'builder-profile-service.ts');
    let profileServiceContent = fs.readFileSync(profileServicePath, 'utf8');
    
    // Update the imports
    if (!profileServiceContent.includes('import { getSocialLinks }')) {
      profileServiceContent = profileServiceContent.replace(
        /import \{ portfolioItemsToPrisma, socialLinksToPrisma \} from '@\/lib\/types\/builder';/,
        'import { portfolioItemsToPrisma, socialLinksToPrisma } from \'@/lib/types/builder\';\nimport { getSocialLinks } from \'@/lib/prisma-types\';'
      );
    }
    
    // Write the updated file
    fs.writeFileSync(profileServicePath, profileServiceContent, 'utf8');
    console.log(`${colors.green}✓ Updated builder-profile-service.ts${colors.reset}`);
    
    return true;
  } catch (error) {
    console.error(`${colors.red}Error updating builder services: ${error.message}${colors.reset}`);
    return false;
  }
}

// Step 6: Fix Portfolio Gallery component
async function fixPortfolioGallery() {
  console.log(`\n${colors.yellow}Step 6: Fixing Portfolio Gallery component...${colors.reset}`);
  
  try {
    const galleryPath = path.join(ROOT_DIR, 'app', '(platform)', 'builder', 'profile', 'components', 'portfolio-gallery.tsx');
    let galleryContent = fs.readFileSync(galleryPath, 'utf8');
    
    // Fix the date issue (add null check)
    galleryContent = galleryContent.replace(
      /const formattedDate = new Date\(project\.date\)\.toLocaleDateString/,
      'const formattedDate = project.date ? new Date(project.date).toLocaleDateString'
    );
    
    // Fix the images issue (add null check)
    galleryContent = galleryContent.replace(
      /src=\{project\.images\[0\] \|\| '\/placeholder-project\.png'\}/,
      "src={(project.images && project.images[0]) || '/placeholder-project.png'}"
    );
    
    // Write the updated file
    fs.writeFileSync(galleryPath, galleryContent, 'utf8');
    console.log(`${colors.green}✓ Fixed Portfolio Gallery component${colors.reset}`);
    return true;
  } catch (error) {
    console.error(`${colors.red}Error fixing Portfolio Gallery: ${error.message}${colors.reset}`);
    return false;
  }
}

// Step 7: Update package.json version
async function updatePackageVersion() {
  console.log(`\n${colors.yellow}Step 7: Updating package version...${colors.reset}`);
  
  try {
    const packagePath = path.join(ROOT_DIR, 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    
    // Increment the patch version
    const versionParts = packageJson.version.split('.');
    versionParts[2] = parseInt(versionParts[2], 10) + 1;
    packageJson.version = versionParts.join('.');
    
    // Write the updated package.json
    fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2), 'utf8');
    console.log(`${colors.green}✓ Updated package version to ${packageJson.version}${colors.reset}`);
    return true;
  } catch (error) {
    console.error(`${colors.red}Error updating package version: ${error.message}${colors.reset}`);
    return false;
  }
}

// Main function to run all steps
async function main() {
  const steps = [
    { name: 'Update Prisma Schema', fn: updatePrismaSchema },
    { name: 'Generate Prisma Client', fn: generatePrismaClient },
    { name: 'Create Prisma Types', fn: createPrismaTypes },
    { name: 'Update Builder Type', fn: updateBuilderType },
    { name: 'Update Builder Services', fn: updateBuilderServices },
    { name: 'Fix Portfolio Gallery', fn: fixPortfolioGallery },
    { name: 'Update Package Version', fn: updatePackageVersion }
  ];
  
  let allSuccessful = true;
  
  for (const step of steps) {
    const success = await step.fn();
    if (!success) {
      allSuccessful = false;
      console.error(`${colors.red}Failed to complete step: ${step.name}${colors.reset}`);
      break;
    }
  }
  
  if (allSuccessful) {
    console.log(`\n${colors.bright}${colors.green}All steps completed successfully!${colors.reset}`);
    console.log(`\nNext steps:
1. Run '${colors.cyan}pnpm type-check${colors.reset}' to verify the fixes
2. If any errors remain:
   - Add necessary null checks where needed
   - Update mockData files if needed (or ignore them for production)
3. Run '${colors.cyan}npm run dev${colors.reset}' to test the application`);
  } else {
    console.log(`\n${colors.bright}${colors.red}Some steps failed to complete. Please check the errors above.${colors.reset}`);
  }
}

// Run the main function
main().catch(error => {
  console.error(`${colors.red}Unhandled error: ${error.message}${colors.reset}`);
  process.exit(1);
});
